{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/juliankrispel/projects/zettel-new/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst getDomSelection_1 = require(\"../selection/getDomSelection\");\n\nconst id_1 = require(\"../EditorState/id\");\n\nconst getBlockForIndex_1 = require(\"../getBlockForIndex\");\n\nconst getIndexBefore_1 = require(\"../getIndexBefore\");\n\nconst actionKeys = ['Backspace', 'Delete', 'Meta', 'Alt', 'Enter', 'Control', 'Shift', 'Tab', 'Escape', 'CapsLock'];\n\nconst isCharacterInsert = e => !e.altKey && !e.metaKey && !e.ctrlKey && !e.key.includes('Arrow') && !actionKeys.includes(e.key);\n\nconst isCopy = e => e.metaKey && e.key === 'c';\n\nconst isPaste = e => e.metaKey && e.key === 'v';\n\nconst isUndo = e => !e.shiftKey && e.metaKey && e.key === 'z';\n\nconst isRedo = e => e.shiftKey && e.metaKey && e.key === 'z';\n\nfunction handleKeyDown(editorState, event) {\n  let newEditorState = editorState;\n  const position = getDomSelection_1.default(editorState.list);\n\n  if (position === null) {\n    console.warn('cant get start and end selection');\n    return editorState;\n  }\n\n  const _position = _slicedToArray(position, 2),\n        start = _position[0],\n        end = _position[1];\n\n  const isCollapsed = start === end;\n\n  if (isUndo(event)) {\n    event.preventDefault();\n    newEditorState = editorState.undo();\n  } else if (isRedo(event)) {\n    event.preventDefault();\n    newEditorState = editorState.redo();\n  } else if (isCollapsed && event.key === 'Backspace' && event.metaKey === true) {\n    event.preventDefault();\n    const prevChar = editorState.list.value[start - 1];\n\n    if (prevChar.type == null) {\n      const blockBeginning = getIndexBefore_1.default(editorState.list.value, start, ch => {\n        if (ch.type === 'block-start') {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (blockBeginning != null) {\n        newEditorState = editorState.change({\n          start: blockBeginning + 1,\n          end,\n          value: []\n        });\n      }\n    }\n  } else if (isCollapsed && event.key === 'Backspace' && event.altKey === true) {\n    event.preventDefault();\n    const prevChar = editorState.list.value[start - 1];\n\n    if (prevChar.type == null) {\n      let spaceBefore = false;\n      let isBlockStart = false;\n      const prevWordEnd = getIndexBefore_1.default(editorState.list.value, start, ch => {\n        if (ch.type !== 'block-start' && ch.type !== 'block-end') {\n          spaceBefore = ch.char === ' ';\n        }\n\n        if (ch.type === 'block-start') {\n          isBlockStart = true;\n          return true;\n        }\n\n        if (ch.type == null && spaceBefore) {\n          return true;\n        }\n\n        return false;\n      });\n\n      if (prevWordEnd != null) {\n        newEditorState = editorState.change({\n          start: isBlockStart ? prevWordEnd + 1 : prevWordEnd,\n          end,\n          value: []\n        });\n      }\n    }\n  } else if (event.key === 'Backspace' && isCollapsed) {\n    event.preventDefault();\n    const previousCharIndex = getIndexBefore_1.default(editorState.list.value, start, ch => ch.type == null || ch.type === 'block-end');\n\n    if (previousCharIndex != null) {\n      const prevChar = editorState.list.value[previousCharIndex];\n      let _start = previousCharIndex;\n\n      if (prevChar.type === 'block-start') {\n        _start++;\n      }\n\n      newEditorState = editorState.change({\n        start: _start,\n        end,\n        value: []\n      }).change({\n        start: _start,\n        end: _start,\n        value: []\n      });\n    }\n  } else if (event.key === 'Backspace' && !isCollapsed) {\n    event.preventDefault();\n    newEditorState = editorState.change({\n      start,\n      end,\n      value: []\n    }).change({\n      start,\n      end: start,\n      value: []\n    });\n  } else if (event.key === 'Enter') {\n    event.preventDefault();\n\n    const _getBlockForIndex_1$d = getBlockForIndex_1.default(editorState.list.value, start),\n          currentBlock = _getBlockForIndex_1$d.block;\n\n    const changed = editorState.change({\n      start,\n      end,\n      value: [{\n        type: 'block-end'\n      }, Object.assign({}, currentBlock, {\n        type: 'block-start',\n        blockKey: id_1.default()\n      })]\n    }).change({\n      start: end + 2,\n      end: end + 2,\n      value: []\n    });\n    newEditorState = changed;\n  } else if (event.key === 'Delete' && isCollapsed) {\n    event.preventDefault();\n    const change = {\n      start,\n      end,\n      value: []\n    };\n    const changed = editorState.change(change);\n    newEditorState = changed;\n  } else if (event.key === 'Delete') {\n    event.preventDefault();\n  } else if (isCharacterInsert(event)) {\n    event.preventDefault();\n    newEditorState = editorState.change({\n      start,\n      end,\n      value: [{\n        char: event.key,\n        styles: []\n      }]\n    }).change({\n      start: start + event.key.length,\n      end: start + event.key.length,\n      value: []\n    });\n  } else if (isCopy(event)) {\n    console.log('implement internal copy maybe?');\n  } else if (isPaste(event)) {}\n\n  return newEditorState;\n}\n\nexports.default = handleKeyDown;","map":null,"metadata":{},"sourceType":"script"}